## 不同的二叉搜索树 ##
* 例如n=6,循环n从i=1开始
* 现在以3为根，i=3
* 左子树可以由a = [1,2]组合，右子树可以由 b= [4,5,6]组合
* 此时的总的组合树就是 a.length * b.length = 6，就是a和b的笛卡尔积
* dp[i] = (i - 1)* (n - i)
* dp[i] = 2 * 3

```javascript
var numTrees = function(n) {
    // 因为n是从1开始，所以数组长度要加1
    const dp = new Array(n + 1).fill(0)
    dp[0] = 1
    // n的个数循环，外层循环n的个数，内层循环根节点，例如n=5
    // 当n=1时，只有一个节点
    // 当n=2时，根节点可能是1，2 => [1,2] [2,1]
    // 当n=3时，根节点可能是1，2，3 => [1,2,3] [1,3,2] [2,1,3] [2,3,1] [3,2,1] [3,1,2]

    // 此时i相当于公式汇总的n
    for(let i = 1; i <= n; i++) {
        // 根节点
        // 此时j相当于公式中的i
        for(let j = 1; j <= i; j++) {
            dp[i] += dp[j - 1] * dp[i - j]
        }
    }
    return dp[n]
};
console.log(numTrees(3)) //5
```
